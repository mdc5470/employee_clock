
import java.awt.Dimension;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.Scanner;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.WindowConstants;

import com.fazecast.jSerialComm.*;










public class Main {


public static boolean commPortSelected = false;
public static boolean scanInOut = true;
static int oldSeconds = 0;

public static String[] lastMinutePunch = new String[61];
public static String lastPunchName = "";
static EmployeeRecorded punchArray[] = new EmployeeRecorded[15];
static int punchArrayPrintIndex = 0;
static int punchArraySaveIndex = 0;
static int recentPunch = 0;
static final int secondsAfterPunch = 10;
static final int namesToShow = 4;  // Will show one more than what you put because 0 index





static class Action implements ActionListener
{
public void actionPerformed(ActionEvent e)
{

commPortSelected = true;
}
}
static class Action1 implements ActionListener
{
public void actionPerformed(ActionEvent e1)
{
scanInOut = false;
}
}

public static String theMonth(int month){
 String[] monthNames = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"};
 return monthNames[month];
}


// mode 0 returns Month/dd/yyyy,hr:min:sec
// mode 1 returns mm/dd/yyyy,hr:min:sec
// mode 2 returns mm/dd/yyyy
// mode 3 returns hr:min:sec
// mode 4 returns hr:min
// format_12hr will add AM and PM to the time and change it to a 12 hour format

//Tring to find the time with the getTime function 

private static String getTime(int mode,boolean format_12hr)
{
String dateTime = null;

//Creating a function for getting the current Date and Time.
LocalDate currentDate = LocalDate.now();
LocalDateTime currentTime = LocalDateTime.now();


String strMonth = theMonth(currentDate.getMonthValue()-1);

//Finding the year from the currentDate function.
String strYear =  Integer.toString(currentDate.getYear());

//Assigning a 0 to make it two digits. 
String strMonthNum;
if (currentDate.getMonthValue() < 10 ) 
	{strMonthNum = "0" + Integer.toString(currentDate.getMonthValue());}
else 
	{strMonthNum = Integer.toString(currentDate.getMonthValue());}

//Assigning a 0 to make it two digits.
String strDOM;
if (currentDate.getDayOfMonth() < 10 ) 
	{strDOM = "0" + Integer.toString(currentDate.getDayOfMonth());}
else 
	{strDOM = Integer.toString(currentDate.getDayOfMonth());}

//Assigning a 0 to make it two digits.
String strHour;
if (currentTime.getHour() < 10 ) 
	{strHour = "0" + Integer.toString(currentTime.getHour()) ;}
else 
	{strHour = Integer.toString(currentTime.getHour());}

//Assigning a 0 to make it two digits.
String strMinute;
if (currentTime.getMinute() < 10 ) 
	{strMinute = "0" + Integer.toString(currentTime.getMinute());}
else 
	{strMinute = Integer.toString(currentTime.getMinute());}

//Assigning a 0 to make it two digits.
String strSecond;
if (currentTime.getSecond() < 10 ) 
	{strSecond = "0" + Integer.toString(currentTime.getSecond());}
else 
	{strSecond = Integer.toString(currentTime.getSecond());}

String strHour12 = null;


if(currentTime.getHour() < 13 )
{
if(currentTime.getHour() == 0 )
{
strHour12 = "12";
}
else 
{
if (currentTime.getHour() < 10 ) 
{
strHour12 = "0" + Integer.toString(currentTime.getHour()) ;
}
else 
{
strHour12 = Integer.toString(currentTime.getHour());
}
}
}

if(currentTime.getHour() >= 13 )
{
if (currentTime.getHour() < 22 ) 
{
strHour12 = "0" + Integer.toString(currentTime.getHour()-12) ;
}
else 
{
strHour12 = Integer.toString(currentTime.getHour());
}
}


String strAMPM;
if (currentTime.getHour() >= 12)
{strAMPM = "PM";}
else {strAMPM = "AM";}


if (mode == 0)
{ if(format_12hr == true) {strHour = strHour12; strSecond = strSecond + " " + strAMPM; }
dateTime = strMonth +"/"+ strDOM+"/"+strYear +","+strHour+":"+strMinute+":"+strSecond ;
}
if (mode == 1)
{if(format_12hr == true) {strHour = strHour12; strSecond = strSecond + " " + strAMPM; }
dateTime = strMonthNum +"/"+ strDOM+"/"+strYear +","+strHour+":"+strMinute+":"+strSecond ;
}
if (mode == 2)
{
dateTime = strMonthNum +"/"+ strDOM+"/"+strYear;
}
if (mode == 3)
{if(format_12hr == true) {strHour = strHour12; strSecond = strSecond + " " + strAMPM; }
dateTime = strHour+":"+strMinute+":"+strSecond ;
}
if (mode == 4)
{if(format_12hr == true) {strHour = strHour12; strMinute = strMinute + " " + strAMPM; }
dateTime = strHour+":"+strMinute ;
}
return dateTime;
}


private static boolean savePunchToFile (String punch_In_Out, String employee_Name) 
throws IOException {

String dateTime = getTime(1,false);
String data = punch_In_Out.concat(",").concat(employee_Name).concat(",").concat(dateTime);

	//File location commented out depending on what machine the program will be used.
    //String filelocation =File.separator + "Users" + File.separator + "Container"+ File.separator + "Dropbox" + File.separator +"Control Room Shared"+ File.separator + "Java" + File.separator +"TC_Text_Files" + File.separator + "punchInOutFile.txt";
	String filelocation =File.separator + "Users" + File.separator + "Jobie"+ File.separator + "Desktop" + File.separator + "Java_Text_Files" + File.separator  + "punchInOutFile.txt";
	File punchInOutFile = new File(filelocation);
       if(!punchInOutFile.exists()) {
       try {
    	   	punchInOutFile.createNewFile();
       		} catch (IOException e) {e.printStackTrace();}}
       try {
    	   
decryptFile("GreeneTeamPellet", filelocation, filelocation);
       		} catch (InvalidKeyException | NoSuchAlgorithmException | NoSuchPaddingException | IllegalBlockSizeException
       						| BadPaddingException | IOException e2) {e2.printStackTrace();}

       FileWriter fileWriter;
       fileWriter = new FileWriter(filelocation,true);
       BufferedWriter bw = new BufferedWriter(fileWriter);
       try {
    	   
bw.write(data);
       		
       } catch (IOException e) {e.printStackTrace();}
       try {

 bw.newLine();

       } catch (IOException e) {e.printStackTrace();}
       try {
    	   
bw.close();} catch (IOException e) {e.printStackTrace();}
       
       try {

encryptFile("GreeneTeamPellet", filelocation, filelocation);

} catch (InvalidKeyException | NoSuchAlgorithmException | NoSuchPaddingException | IllegalBlockSizeException
							| BadPaddingException | IOException e) {e.printStackTrace();}

       return true;
}


// Read in data from serial port and save decrypted data to file
private static void clockInOut(SerialPort localport) throws InvalidKeyException, NoSuchAlgorithmException, IllegalBlockSizeException, BadPaddingException
{
boolean noMatchFound = false;
boolean	savePunchPermissive = true;
String readerNumber = null;
boolean newCardScanned = false;
String number = null ;
BufferedReader data = new BufferedReader(new InputStreamReader(localport.getInputStream()));

//BufferedReader data = new BufferedReader(new InputStreamReader(System.in));
try {
while(data.ready() & newCardScanned == false)
	//number = data.readLine();
	{
		try 
			{number = data.readLine();
			//String s = number;
			 //System.out.println(s);
			} 
		catch(Exception e) {
			System.out.println("ERROR ON DATA.READLINE");
		}
		// Delay 50 ms to allow buffer to fill
		Thread.sleep(50);
		readerNumber = number.substring(0,1);
		number = number.substring(1);
		newCardScanned = true;
	}}

catch (Exception e) {e.printStackTrace();} 

try {
data.close();}

		catch (IOException e2) {e2.printStackTrace();}

String readerInOutString = "";




//Once per second send current time to the Display
//Once per second use nowSeconds for array index for lastMinutePunch and clear that Piece of data
//Then check to see if it is okay to save to the file if the employees name is not in the array
int nowSeconds = (LocalDateTime.now()).getSecond();
if(oldSeconds != nowSeconds) 
	{
		lastMinutePunch[nowSeconds] = "";
		oldSeconds = nowSeconds;
		OutputStream timeOutputToPort = localport.getOutputStream();
try {
	String timeString = "Time," + getTime(0,true); 
	timeOutputToPort.write(timeString.getBytes());
	Thread.sleep(150);
	}
					catch (Exception e) {e.printStackTrace();}
if(recentPunch > -1) {
recentPunch--;}
if(recentPunch <=0)
{
try {
	String returnString = punchArray[punchArrayPrintIndex].makeString();
	System.out.println(returnString);
	timeOutputToPort.write(returnString.getBytes());
	Thread.sleep(150);
} 
catch (Exception e) {e.printStackTrace();}
}

try {
	//String ss = punchArray[punchArrayPrintIndex].makeString();
	//System.out.print("Print Index = "+ punchArrayPrintIndex + "   ");
	
//	System.out.println(punchArray[punchArrayPrintIndex].makeString());
	//System.out.println(punchArray[punchArrayPrintIndex].eName + punchArray[punchArrayPrintIndex].inOut + punchArray[punchArrayPrintIndex].timeStamp );
}
	catch (Exception e) {e.printStackTrace();}
if((nowSeconds%3 ==0))
		{
			if(punchArrayPrintIndex >= namesToShow)
				{punchArrayPrintIndex = 0;}
			else
				{punchArrayPrintIndex++ ;}
		}
	




try {
	timeOutputToPort.flush();
	Thread.sleep(50);
	}
					catch (Exception e) {e.printStackTrace();}

		}
	



while (newCardScanned == true)
{

try {
//C:\Users\Container\Dropbox\Control Room Shared\Java\TC_Text_Files

	
String filelocation =File.separator + "Users" + File.separator + "Jobie"+ File.separator + "Desktop" + File.separator + "Java_Text_Files" + File.separator + "EmployeeRFIDTable.txt";	
//String filelocation =File.separator + "Users" + File.separator + "Container"+ File.separator + "Dropbox" + File.separator +"Control Room Shared"+ File.separator + "Java" + File.separator +"TC_Text_Files" + File.separator + "EmployeeRFIDTable.txt";
File employeeFile = new File(filelocation);
// use scanner that will read from the file
Scanner employeeScanner = new Scanner(employeeFile);
// read a line from the file
String nextLine = employeeScanner.nextLine();


String[] employeeInfo = new String[2];

employeeInfo = nextLine.split(",");

while((!(employeeInfo[0].contentEquals(number))) & employeeScanner.hasNextLine()){
	nextLine = employeeScanner.nextLine();
	employeeInfo = nextLine.split(",");
}

if(readerNumber.contentEquals("0")){
	readerInOutString = "IN";
}

else{
	readerInOutString = "OUT";
}

if(employeeInfo[0].contentEquals("end")){
	System.out.println("No match found");
	noMatchFound = true;
}
else{
	noMatchFound = false;
}

if (noMatchFound == false){
	savePunchPermissive = true;
//Decide whether or not to save data based on whether it is valid
	for (int i=0  ;  i< lastMinutePunch.length  ; i++){	
//String str1 = lastMinutePunch[i];
//String str2 = employeeInfo[1];
	

		if(( lastMinutePunch[i].contentEquals(employeeInfo[1])) == true ){
//if((str1.contentEquals(str2)) == true )
			savePunchPermissive = false;
//System.out.print(str1.contentEquals(str2));

//System.out.println(str2);
		}
	}
}

// This is where the info is saved to a file and saved into an array of objects
if (savePunchPermissive && (noMatchFound == false)){
	try{
		lastMinutePunch[oldSeconds] = employeeInfo[1];
		savePunchToFile (readerInOutString, employeeInfo[1]);
		savePunchPermissive = false;
	} 
	
	catch (Exception e1){
		e1.printStackTrace();
	}
			
//Save info into an object
//EmployeeRecorded punchArray[] = new EmployeeRecorded[10];
//int punchArrayPrintIndex;
//int punchArraySaveIndex;

punchArray[punchArraySaveIndex].eName = employeeInfo[1];
System.out.println(punchArray[punchArraySaveIndex].eName);
punchArray[punchArraySaveIndex].inOut = readerInOutString;
punchArray[punchArraySaveIndex].timeStamp = getTime(4,true);
if(punchArraySaveIndex >= namesToShow){
	punchArraySaveIndex = 0;
}
else{
	punchArraySaveIndex++ ;
}
	
	
OutputStream mOutputToPort = localport.getOutputStream();
try{
	String returnString = "Ename," + employeeInfo[1]+ ","+ "  " + readerInOutString+ "  " + getTime(4,true);
	mOutputToPort.write(returnString.getBytes());
	recentPunch = secondsAfterPunch;
} 
catch (IOException e){
	e.printStackTrace();
}

try {
	mOutputToPort.flush();
}
catch (IOException e){
	e.printStackTrace();
}

Thread.sleep(250);
	}



employeeScanner.close();
newCardScanned = false;
//scanInOut = false;
//port.closePort();
}
catch (FileNotFoundException | InterruptedException ex)
{
System.out.println("File could not be found");
} 
}}


private static SerialPort initializeCommPort()
{

JFrame window = new JFrame("SelectCommPort");
window.setPreferredSize(new Dimension (300,250));  
   window.setLayout(null);
//window.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);



SerialPort localport = null;
   SerialPort localports[] = SerialPort.getCommPorts();
//System.out.println("Select a Port");
int i = 0;
String[] commPortName = {"","","","","","",""};

for (SerialPort port1 : localports) {
//System.out.println(i++ + ".  " + port1.getSystemPortName());
commPortName[i] = port1.getSystemPortName();
i++;
}
JComboBox<String> portsComboBox = new JComboBox<>(commPortName);

JButton cPSelectButton=new JButton("Select Comm Port");


JLabel CommPortHelpLabel = new JLabel("Most Likely COM 4");
Font CommPortHelpFont = new Font("sansserif bold", Font.PLAIN , 16);
CommPortHelpLabel .setFont(CommPortHelpFont);
CommPortHelpLabel .setBounds(50,50,500,30);
window.add(CommPortHelpLabel );


cPSelectButton.setBounds(50,160,200,30);  
window.add(cPSelectButton);
window.add(portsComboBox);
portsComboBox.setBounds(50,100,100,30);
window.setLocation(600, 400);
window.pack();
window.setVisible(true);

while (commPortSelected == false)
{
try {
Thread.sleep(50);
} catch (InterruptedException e) {e.printStackTrace();}

cPSelectButton.addActionListener(new Action());
}

int chosenPort = portsComboBox.getSelectedIndex();
   localport = localports[chosenPort ];
   localport.setComPortTimeouts(SerialPort.TIMEOUT_READ_SEMI_BLOCKING, 0, 0);


if(localport.openPort())
{
System.out.println("Sucessfully opened the port");
window.dispose();

}
else
{
localport.closePort();
System.out.println("Unable to open the port");
window.dispose();

JFrame errorEndProgramWindow = new JFrame("Message");
JOptionPane.showMessageDialog(errorEndProgramWindow,"Comm Port could not be opened. Unplug and replug cable.","Error",JOptionPane.WARNING_MESSAGE);  
  errorEndProgramWindow.setVisible(true);
  System.exit(0);
  
}
return localport;
}


public static void encryptFile(String secretKey, String fileInputPath, String fileOutPath)
 throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IOException,
 IllegalBlockSizeException, BadPaddingException {
Key key = new SecretKeySpec(secretKey.getBytes(), "AES");
Cipher cipher = Cipher.getInstance("AES");
cipher.init(Cipher.ENCRYPT_MODE, key);

 File fileInput = new File(fileInputPath);
 FileInputStream inputStream = new FileInputStream(fileInput);
 byte[] inputBytes = new byte[(int) fileInput.length()];
inputStream.read(inputBytes);

 byte[] outputBytes = cipher.doFinal(inputBytes);

File fileEncryptOut = new File(fileOutPath);
FileOutputStream outputStream = new FileOutputStream(fileEncryptOut);
outputStream.write(outputBytes);

inputStream.close();
outputStream.close();

//System.out.println("File successfully encrypted!");
//System.out.println("New File: " + fileOutPath);
}



public static void decryptFile(String secretKey, String fileInputPath, String fileOutPath)
 throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IOException,
 IllegalBlockSizeException, BadPaddingException {
Key key = new SecretKeySpec(secretKey.getBytes(), "AES");
 Cipher cipher = Cipher.getInstance("AES");
cipher.init(Cipher.DECRYPT_MODE, key);

File fileInput = new File(fileInputPath);
 FileInputStream inputStream = new FileInputStream(fileInput);
 byte[] inputBytes = new byte[(int) fileInput.length()];
inputStream.read(inputBytes);

byte[] outputBytes = cipher.doFinal(inputBytes);

 File fileEncryptOut = new File(fileOutPath);
 FileOutputStream outputStream = new FileOutputStream(fileEncryptOut);
outputStream.write(outputBytes);

inputStream.close();
outputStream.close();

//System.out.println("File successfully decrypted!");
//System.out.println("New File: " + fileOutPath);
}



public static void main(String[] args) {


//Launch window to handle initialization of Comm port settings.
SerialPort port = initializeCommPort();

// Initialize global array of strings that holds names of recent clock ins in the last 60 seconds
//String[] lastMinutePunch = new String[60];
for (int i=0  ;  i< lastMinutePunch.length  ; i++)
	lastMinutePunch[i]="";

for (Integer i = 0; i < punchArray.length ;i++ ){
    punchArray[i] = new EmployeeRecorded();
}

JFrame mainmenu = new JFrame("Time Card");

mainmenu.setPreferredSize(new Dimension (300,250));  
	mainmenu.setLayout(null);
	JButton endProgramButton =new JButton("End Program");
	JLabel mainMenuLabel = new JLabel("Ready To Scan In or Out");
	Font mmf = new Font("sansserif bold", Font.PLAIN, 18);
	mainMenuLabel.setFont(mmf);
	endProgramButton.setBounds(50,160,200,30);
	mainMenuLabel.setBounds(50,50,300,30);
	mainmenu.add(endProgramButton);
	mainmenu.add(mainMenuLabel);
	mainmenu.setLocation(600, 400);
	mainmenu.pack();
	mainmenu.setVisible(true);
	endProgramButton.addActionListener(new Action1());
	mainmenu.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
//
while(scanInOut == true)
{

	
	
	
	try {
		clockInOut(port);
	} catch (InvalidKeyException | NoSuchAlgorithmException | IllegalBlockSizeException | BadPaddingException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
}
port.closePort();
mainmenu.dispose();

}
}


